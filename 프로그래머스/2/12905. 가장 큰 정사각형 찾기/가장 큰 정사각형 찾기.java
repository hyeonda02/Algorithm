// 가장 큰 정사각형의 개수
// 행과 열은 최대 1000

// 1. 해당 배열에 담긴 숫자가 1인지를 확인해야 함.
// 2. 가로 세로의 길이를 확인해야함
// 만약 최댓값이라면, 그 옆에부분은 확인하지 않아도 됨

// 예시
// 0 0 1 1
// 1 1 1 1

// for문 돌면서,, [0][2] 위치에서 1 발견 해당 위치를 기준으로 1이 3까지 이어짐 (길이 1)
// 그리고 아래로 내려가면서 세보면 1까지 이어짐 (길이 1) 총 넓이 4
// 결국 최댓값을 아려면 각 칸에서 정사각형 넓이가 뭔지 확인
// 위 예시의 경우
// 0 0 4 1
// 1 1 1 1 (밑으로 내려가는 넓이만 셈-> 어차피 위에서 최댓값 나오므로..) -> 시간 초과^^

// 넓이를 하나하나 구하는건 아닌것 같다..
// 아니면.. 길이를 저장?
// 위 예시 같은 경우엔
// 0 0 1 1
// 1 1 1 2

// 대각선 방향과 위, 좌를 확인해야됨
// 문제의 예시에 대입
// 1 0 0 0
// 0 1 1 1
// 1 1 2 2
// 1 2 2 3
// 0 0 0 0

// 좌 위 대각선 중 제일 작은값 +1
// dp[i][j] 의 값은 현 위치에서 정사각형의 길이 따라서 3*3 = 9

 
import java.util.*;

class Solution{
    public int solution(int [][]board){
        int answer = 0;
        int[][] dp = new int[board.length][board[0].length];
        
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                if(board[i][j]==1){
                    
                    if(i==0||j==0) {
                        dp[i][j] = 1;
                    }else{
                        dp[i][j] = Math.min(Math.min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1])+1;
                    }
                    if(dp[i][j] > answer) answer = dp[i][j];
                    
                }else{
                    dp[i][j]=0;
                }
            }
        }
            return answer*answer;
    }
}